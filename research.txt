
Relatório Arquitetural de Engenharia: Implementação de Explorador de Catálogo de Dados Unity Catalog em React e FastAPI


1. Introdução e Fundamentos Arquiteturais


1.1. Escopo e Objetivos Estratégicos

O presente relatório técnico estabelece o plano diretor para a implementação de um componente de "Explorador de Banco de Dados" (Database Explorer) dentro de uma aplicação de dashboard integrada ao Databricks. O objetivo primordial é replicar e expandir a funcionalidade de navegação hierárquica encontrada em IDEs de banco de dados tradicionais (como DBeaver, DataGrip) e na própria interface nativa do Databricks SQL Editor, permitindo que engenheiros de dados e analistas naveguem fluidamente pela estrutura do Unity Catalog.
A arquitetura proposta deve resolver o desafio de visualizar grandes volumes de metadados — potencialmente milhares de catálogos, esquemas e tabelas — sem comprometer a performance do frontend. A solução adotará uma abordagem "from scratch" (do zero) no desenvolvimento dos componentes de interface em React, priorizando o controle absoluto sobre a renderização e o gerenciamento de estado, em detrimento do uso de bibliotecas de componentes de terceiros "caixa-preta" que frequentemente introduzem inchaço (bloat) e limitações de customização. No backend, a estratégia baseia-se na extensão do serviço FastAPI existente para atuar como um proxy inteligente e seguro para as APIs REST do Unity Catalog e a API de Execução de Declarações SQL do Databricks.1
Este documento detalha a análise dos requisitos de governança de dados impostos pelo Unity Catalog, a teoria por trás da virtualização de listas hierárquicas em interfaces web modernas, e o protocolo de comunicação otimizado entre o cliente React e o servidor Python.

1.2. O Modelo de Objetos do Unity Catalog e Implicações de UI

Para projetar um explorador eficaz, é imperativo compreender a ontologia do Unity Catalog, pois ela dita a estrutura da árvore de navegação. O Unity Catalog organiza os dados em uma hierarquia de três níveis, que deve ser refletida fielmente na interface do usuário:
Metastore: O contêiner de nível superior de metadados. Cada espaço de trabalho (workspace) do Databricks está anexado a um metastore.2 A aplicação deve ser capaz de identificar o metastore ativo, embora a navegação geralmente comece no nível do Catálogo.
Catálogo (Catalog): O primeiro nível da hierarquia de dados (ex: main, samples). Serve como agrupador lógico e barreira de isolamento de dados. A interface deve listar todos os catálogos visíveis ao usuário.3
Esquema (Schema/Database): O segundo nível (ex: default, nyctaxi). Contém tabelas, visualizações e funções. A navegação deve permitir a expansão de um catálogo para revelar seus esquemas.5
Tabelas e Visualizações (Tables & Views): O terceiro nível, contendo os ativos de dados reais. Tabelas podem ser gerenciadas (Managed) ou externas (External), e a interface deve, idealmente, distinguir visualmente entre tabelas, visualizações e visualizações materializadas através de ícones distintos.7
Colunas e Metadados: Embora não sejam nós de navegação primários, a seleção de uma tabela deve revelar suas colunas, tipos de dados e comentários, exigindo chamadas de API adicionais ou consultas ao INFORMATION_SCHEMA.8
A tabela abaixo resume o mapeamento entre os objetos do Unity Catalog e a representação visual proposta na árvore de navegação:
Nível Hierárquico
Entidade Unity Catalog
Representação Visual
Endpoint de Dados (API)
Permissão Necessária
Raiz
Metastore
Container da Árvore
N/A (Implícito no Workspace)
N/A
Nível 1
Catalog
Nó Expansível (Pasta Raiz)
/api/2.1/unity-catalog/catalogs
USE CATALOG ou BROWSE
Nível 2
Schema
Nó Expansível (Subpasta)
/api/2.1/unity-catalog/schemas
USE SCHEMA
Nível 3
Table/View
Nó Terminal (Item Selecionável)
/api/2.1/unity-catalog/tables
SELECT
Painel de Detalhes
Data Grid
Tabela de Dados (Spreadsheet)
SQL Statement API (SELECT *)
SELECT


1.3. O Problema da Escala e a Necessidade de Virtualização

Um ambiente corporativo Databricks típico não é trivial. Pode conter dezenas de catálogos, centenas de esquemas por catálogo e milhares de tabelas por esquema. Renderizar essa estrutura usando componentes HTML padrão (como listas não ordenadas <ul> aninhadas recursivamente) resulta em uma árvore DOM (Document Object Model) excessivamente grande.
Navegadores web modernos, embora otimizados, sofrem degradação significativa de performance (conhecida como "jank") quando o número de nós DOM excede alguns milhares. Operações de reflow e repaint tornam-se custosas, causando travamentos na rolagem e atrasos na expansão de pastas.
A análise de arquitetura frontend indica que a única solução viável para um explorador de banco de dados de nível de produção é a Virtualização de Lista (ou "Windowing"). Esta técnica envolve renderizar apenas os itens que estão atualmente visíveis na "janela" de visualização do usuário (viewport), reciclando os elementos DOM à medida que o usuário rola a lista.10
Para uma estrutura de árvore, isso apresenta um desafio algorítmico: a árvore deve ser "achatada" (flattened) em uma lista linear para ser compatível com bibliotecas de virtualização como react-window. Este relatório detalhará o algoritmo de projeção necessário para transformar a estrutura hierárquica de dados do Unity Catalog em uma estrutura linear virtualizável.

2. Estratégia de Integração Backend: FastAPI e Databricks

A integração com o Databricks deve ser robusta, segura e performática. O código atual do backend 1 sugere uma arquitetura baseada em serviços, onde o FastAPI atua como um orquestrador. A comunicação direta do frontend com o Databricks é desencorajada por razões de segurança (exposição de tokens) e CORS.

2.1. Análise Comparativa: SQL API vs. REST API para Metadados

Para popular a árvore de navegação, existem duas abordagens principais para recuperar metadados:
Execução de Comandos SQL via JDBC/ODBC ou Statement Execution API:
Comandos: SHOW CATALOGS, SHOW SCHEMAS IN catalog, SHOW TABLES IN schema.
Vantagens: Utiliza a mesma infraestrutura de execução que as consultas de dados.
Desvantagens: Latência elevada. Cada comando SQL precisa ser analisado, planejado e executado pelo SQL Warehouse, que pode ter tempos de inicialização (cold start) ou filas. A resposta é frequentemente texto não estruturado ou tabular simples, exigindo parsing adicional. Além disso, a paginação de milhares de tabelas via SQL é complexa e ineficiente.3
Unity Catalog REST API (/api/2.1/unity-catalog/...):
Vantagens: Projetada especificamente para operações de metadados. Oferece respostas JSON estruturadas, baixa latência (não requer um cluster Spark "quente" para metadados simples), paginação nativa via page_token e filtragem rica.12
Desvantagens: Requer gerenciamento de escopo de token apropriado.
Decisão Arquitetural: A solução adotará uma Abordagem Híbrida.
Navegação na Árvore (Metadados): Utilizará estritamente a Unity Catalog REST API via backend FastAPI. Isso garante que a expansão de pastas na UI seja quase instantânea, desacoplada da carga do SQL Warehouse.
Visualização de Dados (Data Grid): Utilizará a SQL Statement Execution API (/api/2.0/sql/statements) para executar consultas SELECT e TABLESAMPLE. Isso é necessário porque a API REST do Unity Catalog não fornece acesso aos dados (linhas), apenas aos metadados.2

2.2. Design da Camada de Serviço Python (databricks_service)

O arquivo backend/app/services/databricks.py deve ser expandido para encapsular a lógica de comunicação com o Unity Catalog. Atualmente, ele foca em execução SQL e DBFS. A nova implementação deve adicionar métodos específicos para descoberta de catálogo.

2.2.1. Implementação dos Métodos de Descoberta

Abaixo, apresenta-se a lógica detalhada para a implementação dos métodos de recuperação de metadados, enfatizando o tratamento de erros e a transformação de dados.

Python


# Extensão proposta para backend/app/services/databricks.py

def list_catalogs(self):
    """
    Recupera a lista de catálogos do metastore atual.
    Utiliza o endpoint GET /api/2.1/unity-catalog/catalogs.
    """
    config = get_databricks_config()
    if not config:
        return self._get_mock_catalogs()

    url = f"{config.host.rstrip('/')}/api/2.1/unity-catalog/catalogs"
    headers = self._get_headers(config)
    
    # Implementação de paginação robusta
    catalogs =
    page_token = None
    
    while True:
        params = {}
        if page_token:
            params['page_token'] = page_token
            
        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()
            
            if 'catalogs' in data:
                catalogs.extend(data['catalogs'])
            
            page_token = data.get('next_page_token')
            if not page_token:
                break
                
        except requests.exceptions.RequestException as e:
            # Log error appropriate to production environment
            raise ValueError(f"Falha ao listar catálogos: {str(e)}")

    # Filtragem opcional ou transformação pode ocorrer aqui
    return catalogs

def list_schemas(self, catalog_name: str):
    """
    Lista esquemas dentro de um catálogo específico.
    Endpoint: GET /api/2.1/unity-catalog/schemas
    """
    config = get_databricks_config()
    #... (verificação de config e mock)

    url = f"{config.host.rstrip('/')}/api/2.1/unity-catalog/schemas"
    headers = self._get_headers(config)
    params = {'catalog_name': catalog_name}
    
    # Paginação similar ao método list_catalogs deve ser implementada
    #...
    
    return schemas

def list_tables(self, catalog_name: str, schema_name: str):
    """
    Lista tabelas e views dentro de um esquema.
    Endpoint: GET /api/2.1/unity-catalog/tables
    """
    config = get_databricks_config()
    
    url = f"{config.host.rstrip('/')}/api/2.1/unity-catalog/tables"
    headers = self._get_headers(config)
    params = {
        'catalog_name': catalog_name, 
        'schema_name': schema_name,
        'omit_columns': 'true' # Otimização de performance: não buscar colunas na listagem inicial
    }
    
    #... (lógica de requisição e paginação)
    
    return tables


Análise de Segurança e Permissões:
O backend utiliza um Token de Acesso Pessoal (PAT) ou token OAuth de Service Principal (dapi...) configurado em app.core.config.1 O Unity Catalog impõe controle de acesso baseado em funções (RBAC). Se o token utilizado pelo backend não tiver a permissão USE CATALOG em um catálogo específico, a API simplesmente omitirá esse catálogo da resposta.13 Isso é vantajoso, pois o backend não precisa implementar lógica complexa de filtragem de permissões; ele reflete a "verdade" conforme vista pelo token de serviço. No entanto, é crucial que o token tenha permissões suficientes (idealmente apenas leitura/browse) para servir como um explorador geral, ou que a aplicação implemente um fluxo "On-Behalf-Of" (OBO) se a intenção for mostrar apenas o que o usuário logado pode ver (o que exigiria OAuth 2.0 user-to-server, mais complexo). Assumindo a arquitetura atual baseada em um token de serviço único 1, todos os usuários do dashboard verão o que o Service Principal pode ver.

2.3. Definição das Rotas da API (routes_explorer.py)

Para manter a organização e a separação de preocupações (SoC), recomenda-se criar um novo módulo de rotas backend/app/api/routes_explorer.py em vez de sobrecarregar routes.py ou routes_files.py.
O uso de modelos Pydantic é essencial aqui para garantir que o contrato de dados com o frontend seja rigoroso e documentado automaticamente (via OpenAPI/Swagger).

Python


# backend/app/api/routes_explorer.py
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from pydantic import BaseModel
from app.services.databricks import databricks_service

router = APIRouter()

# Modelos de Resposta Otimizados para o Frontend
class CatalogNode(BaseModel):
    name: str
    type: str = "CATALOG"
    comment: Optional[str] = None

class SchemaNode(BaseModel):
    name: str
    catalog_name: str
    type: str = "SCHEMA"
    comment: Optional[str] = None

class TableNode(BaseModel):
    name: str
    catalog_name: str
    schema_name: str
    table_type: str  # MANAGED, EXTERNAL, VIEW, MATERIALIZED_VIEW
    full_name: str
    type: str = "TABLE"

@router.get("/explorer/catalogs", response_model=List[CatalogNode])
async def get_catalogs():
    """Retorna a lista de catálogos disponíveis."""
    try:
        raw_catalogs = databricks_service.list_catalogs()
        # Transformação de dados brutos da API Databricks para o modelo do frontend
        return [
            CatalogNode(
                name=c['name'], 
                comment=c.get('comment'),
                type="CATALOG"
            ) for c in raw_catalogs
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/explorer/schemas", response_model=List)
async def get_schemas(catalog_name: str = Query(..., description="Nome do catálogo pai")):
    try:
        raw_schemas = databricks_service.list_schemas(catalog_name)
        return, 
                catalog_name=s['catalog_name'],
                comment=s.get('comment')
            ) for s in raw_schemas
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Endpoint análogo para tabelas...


Essa camada de abstração permite que o frontend seja agnóstico quanto às idiossincrasias da API do Databricks (como a mudança de nomes de campos ou estruturas aninhadas complexas), recebendo apenas o que precisa para renderizar a árvore.

3. Engenharia Frontend: Construindo a Árvore Virtualizada

A implementação do frontend em React é o ponto crítico para a experiência do usuário (UX). A seguir, detalha-se a estratégia "from scratch" utilizando react-window para performance máxima.

3.1. Conceitos de Virtualização e Achatamento de Árvore

Para renderizar uma árvore hierárquica em uma lista virtualizada (FixedSizeList do react-window), a estrutura de dados em árvore (nós contendo arrays de filhos) deve ser transformada em uma estrutura linear (array plano) em tempo de execução.10
O algoritmo de "achatamento" (flattening) deve considerar apenas os nós que estão visíveis. Um nó é visível se e somente se todos os seus ancestrais estiverem expandidos.
Algoritmo de Projeção Visual:
Inicie com uma lista vazia visibleNodes.
Itere sobre os nós raiz (Catálogos).
Para cada nó, adicione-o a visibleNodes.
Se o nó estiver no conjunto de expandedIds (estado da UI):
a. Recupere seus filhos (do cache ou estado).
b. Recursivamente aplique o passo 3 e 4 para os filhos.
O resultado é um array onde a ordem dos índices corresponde exatamente à ordem visual vertical na tela.
Este processo deve ser envolto em um useMemo para evitar recálculos desnecessários a cada renderização, recalculando apenas quando expandedIds ou os dados brutos mudarem.15

3.2. Gerenciamento de Estado Assíncrono com React Query

O carregamento de dados sob demanda (Lazy Loading) é mandatório. Não se deve carregar todos os esquemas de todos os catálogos na inicialização. Utilizaremos a biblioteca @tanstack/react-query (presumivelmente disponível ou a ser adicionada, dada sua popularidade no ecossistema React moderno e menção em snippets de melhores práticas 16).
O padrão será:
Ao expandir um nó, verificar se seus filhos já estão no cache.
Se não, disparar a query assíncrona.
Exibir um estado de carregamento (skeleton ou spinner) dentro da estrutura da árvore, logo abaixo do nó pai.

3.3. Arquitetura de Componentes Proposta

A estrutura de arquivos no frontend deve ser expandida da seguinte forma:



frontend/src/
  components/
    explorer/
      DatabaseExplorer.tsx    (Container principal da página)
      ExplorerSidebar.tsx     (Painel lateral com a árvore)
      VirtualTree.tsx         (Implementação da árvore virtualizada)
      TreeNode.tsx            (Renderizador de linha individual)
      TablePreview.tsx        (Visualização de dados da tabela selecionada)
  hooks/
    useDatabaseTree.ts        (Lógica de estado, expansão e achatamento)
    useExplorerData.ts        (Hooks do React Query para buscar API)



4. Implementação Detalhada Passo a Passo

A seguir, apresenta-se o código e a lógica para implementar os componentes centrais.

Passo 1: Camada de Serviço Frontend (services/explorerService.ts)

Primeiro, definimos a interface com o backend FastAPI.

TypeScript


// frontend/services/explorerService.ts
import { api } from './api'; // Assumindo que existe um wrapper base axios/fetch

export interface Catalog {
  name: string;
  type: string;
  comment?: string;
}

export interface Schema {
  name: string;
  catalog_name: string;
  comment?: string;
}

export interface Table {
  name: string;
  schema_name: string;
  catalog_name: string;
  table_type: string; // MANAGED, EXTERNAL, VIEW
  full_name: string;
}

// Funções de fetch tipadas
export const fetchCatalogs = async (): Promise<Catalog> => {
  const response = await fetch('/api/explorer/catalogs');
  if (!response.ok) throw new Error('Erro ao carregar catálogos');
  return response.json();
};

export const fetchSchemas = async (catalog: string): Promise<Schema> => {
  const response = await fetch(`/api/explorer/schemas?catalog_name=${encodeURIComponent(catalog)}`);
  if (!response.ok) throw new Error('Erro ao carregar esquemas');
  return response.json();
};

export const fetchTables = async (catalog: string, schema: string): Promise<Table> => {
  const response = await fetch(`/api/explorer/tables?catalog_name=${encodeURIComponent(catalog)}&schema_name=${encodeURIComponent(schema)}`);
  if (!response.ok) throw new Error('Erro ao carregar tabelas');
  return response.json();
};



Passo 2: Hook de Lógica da Árvore (hooks/useDatabaseTree.ts)

Este hook encapsula a complexidade de manter o estado de expansão e a lógica de achatamento da árvore para a virtualização. Ele utiliza react-query para gerenciar o cache de dados.

TypeScript


import { useState, useMemo, useCallback } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { fetchCatalogs, fetchSchemas, fetchTables } from '../services/explorerService';

export type NodeType = 'CATALOG' | 'SCHEMA' | 'TABLE';

// Estrutura unificada para o nó da árvore visual
export interface TreeNode {
  id: string;           // Identificador único (ex: "main", "main.default", "main.default.trips")
  label: string;        // Texto de exibição
  type: NodeType;
  level: number;        // Profundidade para indentação (0, 1, 2)
  parentId: string | null;
  isLoaded?: boolean;   // Se os filhos já foram carregados
  isLoading?: boolean;  // Estado transiente de carregamento
  data?: any;           // Objeto original (Catalog/Schema/Table)
}

export const useDatabaseTree = () => {
  const queryClient = useQueryClient();
  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());
  
  // 1. Carregar Catálogos (Raiz)
  const { data: catalogs, isLoading: isLoadingCatalogs } = useQuery({
    queryKey: ['catalogs'],
    queryFn: fetchCatalogs
  });

  // Estado local para armazenar filhos carregados sob demanda.
  // Chave = ID do pai, Valor = Lista de nós filhos
  const [loadedChildren, setLoadedChildren] = useState<Record<string, TreeNode>>({});
  const [loadingNodes, setLoadingNodes] = useState<Set<string>>(new Set());

  // Função para alternar expansão/colapso
  const toggleNode = useCallback(async (node: TreeNode) => {
    const newExpanded = new Set(expandedIds);

    if (expandedIds.has(node.id)) {
      // Colapsar
      newExpanded.delete(node.id);
      setExpandedIds(newExpanded);
    } else {
      // Expandir
      newExpanded.add(node.id);
      setExpandedIds(newExpanded);

      // Se ainda não carregou os filhos, buscar na API
      if (!loadedChildren[node.id]) {
        setLoadingNodes(prev => new Set(prev).add(node.id));
        try {
          let children: TreeNode =;
          
          if (node.type === 'CATALOG') {
            const schemas = await queryClient.fetchQuery({
              queryKey: ['schemas', node.label],
              queryFn: () => fetchSchemas(node.label)
            });
            children = schemas.map(s => ({
              id: `${node.label}.${s.name}`,
              label: s.name,
              type: 'SCHEMA',
              level: 1,
              parentId: node.id,
              data: s
            }));
          } else if (node.type === 'SCHEMA') {
            // node.id assume formato "catalog.schema"
            const [catalog, schema] = node.id.split('.');
            const tables = await queryClient.fetchQuery({
              queryKey: ['tables', catalog, schema],
              queryFn: () => fetchTables(catalog, schema)
            });
            children = tables.map(t => ({
              id: `${catalog}.${schema}.${t.name}`,
              label: t.name,
              type: 'TABLE',
              level: 2,
              parentId: node.id,
              data: t
            }));
          }

          setLoadedChildren(prev => ({...prev, [node.id]: children }));
        } catch (err) {
          console.error("Erro ao expandir nó:", err);
          // Em caso de erro, talvez remover do expandedIds para permitir tentar novamente
          newExpanded.delete(node.id);
          setExpandedIds(new Set(newExpanded));
        } finally {
          setLoadingNodes(prev => {
            const next = new Set(prev);
            next.delete(node.id);
            return next;
          });
        }
      }
    }
  }, [expandedIds, loadedChildren, queryClient]);

  // 3. Achatamento (Flattening) da Árvore para Virtualização
  // Recalcula a lista linear sempre que a expansão ou dados mudam.
  const flatList = useMemo(() => {
    if (!catalogs) return;

    const result: TreeNode =;
    
    const processNode = (node: TreeNode) => {
      result.push(node);
      
      // Se expandido, processar filhos
      if (expandedIds.has(node.id)) {
        if (loadingNodes.has(node.id)) {
          // Adicionar nó temporário de loading
          result.push({
            id: `${node.id}-loading`,
            label: 'Carregando...',
            type: 'TABLE', // Tipo dummy
            level: node.level + 1,
            parentId: node.id,
            isLoading: true
          });
        } else {
          const children = loadedChildren[node.id];
          if (children) {
            children.forEach(processNode);
          } else {
            // Caso especial: expandido mas sem filhos (vazio)
            result.push({
                id: `${node.id}-empty`,
                label: '(Vazio)',
                type: 'TABLE', 
                level: node.level + 1,
                parentId: node.id,
                isLoading: false // Apenas visual
            });
          }
        }
      }
    };

    // Converter catálogos raiz em TreeNodes
    const rootNodes: TreeNode = catalogs.map(c => ({
      id: c.name,
      label: c.name,
      type: 'CATALOG',
      level: 0,
      parentId: null,
      data: c
    }));

    rootNodes.forEach(processNode);
    return result;
  }, [catalogs, expandedIds, loadedChildren, loadingNodes]);

  return { flatList, toggleNode, expandedIds, isLoadingCatalogs };
};



Passo 3: Componente Visual (ExplorerSidebar.tsx)

Implementação da sidebar usando react-window para renderizar a flatList.

TypeScript


import React from 'react';
import { FixedSizeList as List, ListChildComponentProps } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { useDatabaseTree, TreeNode } from '../../hooks/useDatabaseTree';
// Ícones importados dos componentes existentes
import { ChevronRightIcon } from '../icons/ChevronRightIcon';
import { ChevronDownIcon } from '../icons/ChevronDownIcon';
import { TableIcon } from '../icons/TableIcon';
import { DatabaseIcon } from '../icons/DatabaseIcon'; // Placeholder para Catalogo
import { FolderIcon } from '../icons/FolderIcon';     // Placeholder para Schema

interface ExplorerSidebarProps {
  onSelectTable: (tableData: any) => void;
}

export const ExplorerSidebar: React.FC<ExplorerSidebarProps> = ({ onSelectTable }) => {
  const { flatList, toggleNode, expandedIds, isLoadingCatalogs } = useDatabaseTree();

  // Renderizador de Linha Otimizado (Memoizado pelo react-window)
  const Row = ({ index, style }: ListChildComponentProps) => {
    const node = flatList[index];
    const isExpanded = expandedIds.has(node.id);
    
    // Cálculo dinâmico de indentação e padding
    // level 0 = 12px, level 1 = 28px, level 2 = 44px
    const paddingLeft = `${node.level * 16 + 12}px`; 

    // Loading State Visual
    if (node.isLoading) {
      return (
        <div style={style} className="flex items-center text-xs text-gray-500 italic select-none">
          <div style={{ paddingLeft }} className="pl-8">Carregando itens...</div>
        </div>
      );
    }

    // Handler de Clique
    const handleClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (node.type === 'TABLE') {
        onSelectTable(node.data);
      } else {
        toggleNode(node);
      }
    };

    // Seleção de Ícones e Cores com base no tipo
    let Icon = DatabaseIcon;
    let colorClass = "text-gray-400";
    
    if (node.type === 'SCHEMA') {
        Icon = FolderIcon; // Usar ícone de pasta se disponível
        colorClass = "text-yellow-500";
    } else if (node.type === 'TABLE') {
        Icon = TableIcon;
        colorClass = "text-blue-400";
    }

    return (
      <div 
        style={style} 
        className={`flex items-center hover:bg-gray-800 cursor-pointer text-sm text-gray-300 select-none transition-colors duration-75
          ${node.type === 'TABLE'? 'hover:text-white' : ''}`}
        onClick={handleClick}
      >
        <div style={{ paddingLeft }} className="flex items-center w-full pr-2 overflow-hidden">
          {/* Botão Expander (Apenas para containers) */}
          <div className="w-5 h-5 flex items-center justify-center mr-1 shrink-0">
            {node.type!== 'TABLE' && (
              <div className="p-0.5 rounded hover:bg-gray-700">
                {isExpanded? <ChevronDownIcon className="w-3 h-3" /> : <ChevronRightIcon className="w-3 h-3" />}
              </div>
            )}
          </div>

          {/* Ícone do Tipo */}
          <Icon className={`w-4 h-4 mr-2 shrink-0 ${colorClass}`} />

          {/* Rótulo com Truncamento */}
          <span className="truncate" title={node.label}>{node.label}</span>
        </div>
      </div>
    );
  };

  if (isLoadingCatalogs) {
    return <div className="p-4 text-gray-400 text-sm">Carregando catálogo...</div>;
  }

  return (
    <div className="h-full flex flex-col bg-gray-900 border-r border-gray-700 w-64 shrink-0">
      <div className="p-3 border-b border-gray-700 flex justify-between items-center bg-gray-900/50 backdrop-blur">
        <span className="font-semibold text-gray-200 text-sm uppercase tracking-wider">Explorer</span>
        {/* Aqui poderia entrar um botão de refresh */}
      </div>
      
      <div className="flex-1 relative">
        {/* AutoSizer garante que a lista ocupe todo o espaço vertical disponível */}
        <AutoSizer>
          {({ height, width }) => (
            <List
              height={height}
              width={width}
              itemCount={flatList.length}
              itemSize={28} // Altura da linha compacta
              itemKey={(index) => flatList[index].id} // Chave estável para performance de diff do React
              overscanCount={5} // Renderizar 5 itens fora da tela para rolagem suave
            >
              {Row}
            </List>
          )}
        </AutoSizer>
      </div>
    </div>
  );
};



Passo 4: Integração na Página Principal (DatabaseExplorerPage.tsx)

Esta página orquestra a interação entre a Sidebar e a área de conteúdo principal (Grid de Dados).

TypeScript


import React, { useState } from 'react';
import { ExplorerSidebar } from '../components/explorer/ExplorerSidebar';
import Spreadsheet from '../components/spreadsheet/Spreadsheet'; // Reutilizando componente existente
import { executeRawQuery } from '../services/dashboardService'; // Serviço que chama /api/query

const DatabaseExplorerPage: React.FC = () => {
  const = useState<any | null>(null);
  const = useState<any>();
  const = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSelectTable = async (table: any) => {
    setActiveTable(table);
    setLoadingData(true);
    setError(null);
    setTableData();
    
    // Constrói a query segura. 
    // Nota: Em produção, usar parameters binding, mas para SELECT * LIMIT é aceitável concatenar
    // se o full_name vier confiável da API do Unity Catalog.
    const query = `SELECT * FROM ${table.full_name} LIMIT 1000`; 
    
    try {
      // Reutiliza o serviço existente que bate no endpoint SQL Statement Execution
      const result = await executeRawQuery(query, 'sql');
      setTableData(result);
    } catch (err) {
      console.error("Falha ao carregar dados da tabela", err);
      setError("Não foi possível carregar os dados. Verifique suas permissões ou se o SQL Warehouse está ativo.");
    } finally {
      setLoadingData(false);
    }
  };

  const handleCloseSpreadsheet = () => {
    setActiveTable(null);
    setTableData();
  };

  return (
    <div className="flex h-full w-full overflow-hidden bg-black">
      {/* Painel Esquerdo: Navegador */}
      <ExplorerSidebar onSelectTable={handleSelectTable} />

      {/* Painel Direito: Conteúdo */}
      <div className="flex-1 flex flex-col relative overflow-hidden">
        {activeTable? (
          <div className="h-full w-full flex flex-col">
            {loadingData? (
              <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400 z-10 bg-black/50 backdrop-blur-sm">
                 <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mb-4"></div>
                 <span>Carregando dados de <strong>{activeTable.name}</strong>...</span>
              </div>
            ) : null}
            
            {error? (
               <div className="p-8 text-center">
                 <div className="text-red-500 text-lg mb-2">Erro</div>
                 <p className="text-gray-400">{error}</p>
               </div>
            ) : (
               <div className="h-full w-full p-0">
                  {/* Reutilização do componente Spreadsheet existente */}
                  <Spreadsheet 
                      title={`Dados: ${activeTable.full_name}`}
                      data={tableData}
                      onClose={handleCloseSpreadsheet}
                      isEditable={false} // Modo leitura para o explorer
                  />
               </div>
            )}
          </div>
        ) : (
          // Estado Vazio (Empty State)
          <div className="flex-1 flex flex-col items-center justify-center text-gray-600 select-none">
            <DatabaseIcon className="w-16 h-16 mb-4 opacity-20" />
            <p>Selecione uma tabela no explorador para visualizar os dados</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default DatabaseExplorerPage;



5. Otimização de Performance e Melhores Práticas

A implementação acima segue princípios rígidos de performance. Abaixo, detalham-se as otimizações aplicadas e recomendações adicionais:
Virtualização com react-window:
Problema: Renderizar 50.000 tabelas travaria o navegador.
Solução: A FixedSizeList renderiza apenas os ~30 itens visíveis na tela. O uso da propriedade itemKey é crucial; ela permite que o React reutilize componentes DOM mesmo quando a lista é reordenada ou filtrada, evitando "flashes" de renderização.
Memoização de Transformação de Dados (useMemo):
A função que "achata" a árvore (processNode em useDatabaseTree) tem complexidade O(N), onde N é o número de nós visíveis. Sem useMemo, essa função rodaria a cada render (ex: cada vez que um componente pai atualiza). O useMemo garante que ela só rode quando expandedIds ou loadedChildren mudam.
Cache de Requisições com React Query:
Ao fechar e reabrir uma pasta, o useQuery serve os dados do cache (staleTime padrão pode ser ajustado para 5-10 minutos para metadados que mudam pouco), proporcionando uma experiência instantânea "snappy".
Tratamento de Estados de Carregamento:
A UI não bloqueia. O indicador de carregamento é inserido como um "nó falso" na árvore. Isso evita que a layout shift (mudança brusca de layout) desoriente o usuário.
Consultas de Dados Eficientes:
O uso de LIMIT 1000 é uma proteção básica. Para tabelas maiores, recomenda-se implementar paginação no nível do SQL (usando OFFSET) ou, idealmente, a cláusula TABLESAMPLE (ex: SELECT * FROM table TABLESAMPLE (100 ROWS)), que é muito mais rápida em tabelas Delta grandes pois evita scan completo.18

6. Conclusão e Roteiro de Evolução

A arquitetura apresentada fornece uma fundação sólida para um explorador de dados integrado ao Databricks. Ao evitar bibliotecas de árvore genéricas e construir a lógica de virtualização sobre primitivas robustas (react-window + Hooks customizados), a aplicação ganha em performance e manutenibilidade.
Próximos Passos Sugeridos:
Busca/Filtro: Implementar uma barra de busca no topo da Sidebar. Isso exigirá um endpoint de busca no backend ou filtragem local na lista achatada (se o dataset total não for proibitivamente grande).
Metadados Estendidos: Adicionar um painel de "Detalhes" (lado direito, em abas com o Spreadsheet) para mostrar schema, particionamento e lineage (usando a API de linhagem do Unity Catalog).20
Abas Múltiplas: Evoluir o DatabaseExplorerPage para suportar múltiplas tabelas abertas simultaneamente em abas, gerenciando um array de activeTables no estado.
Esta implementação atende integralmente aos requisitos de visualizar tabelas do Unity Catalog com a familiaridade de um IDE, respeitando as restrições de segurança e performance do ambiente Databricks.
Works cited
diegomrodrigues2-databricks-dashboard-app-8a5edab282632443 (7).txt
What is Unity Catalog? - Azure Databricks | Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/
SHOW CATALOGS - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-aux-show-catalogs
SHOW CATALOGS | Databricks on AWS, accessed November 25, 2025, https://docs.databricks.com/aws/en/sql/language-manual/sql-ref-syntax-aux-show-catalogs
SHOW SCHEMAS - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-aux-show-schemas
SHOW SCHEMAS | Databricks on AWS, accessed November 25, 2025, https://docs.databricks.com/aws/en/sql/language-manual/sql-ref-syntax-aux-show-schemas
SHOW TABLES - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-aux-show-tables
SHOW TABLE EXTENDED - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-aux-show-table
DESCRIBE TABLE - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-aux-describe-table
Virtualize large lists with react-window | Articles - web.dev, accessed November 25, 2025, https://web.dev/articles/virtualize-long-lists-react-window
List Virtualization - Patterns.dev, accessed November 25, 2025, https://www.patterns.dev/vanilla/virtual-lists/
List tables | Tables API | REST API reference | Databricks on AWS, accessed November 25, 2025, https://docs.databricks.com/api/workspace/tables/list
List catalogs - REST API reference - Databricks documentation, accessed November 25, 2025, https://docs.databricks.com/api/workspace/catalogs/list
Databricks Unity Catalog Analysis: A Comprehensive API-Driven Approach - Medium, accessed November 25, 2025, https://medium.com/@rahulgosavi.94/databricks-unity-catalog-analysis-a-comprehensive-api-driven-approach-dae8c9b121dd
How To Render Large Datasets In React without Killing Performance | Syncfusion Blogs, accessed November 25, 2025, https://www.syncfusion.com/blogs/post/render-large-datasets-in-react/amp
Lazy Loading with React Query - Carl Rippon, accessed November 25, 2025, https://carlrippon.com/lazy-loading-with-react-query/
Fetching Hierarchical data for a tree component · TanStack query · Discussion #413 - GitHub, accessed November 25, 2025, https://github.com/TanStack/query/discussions/413
TABLESAMPLE clause | Databricks on Google Cloud, accessed November 25, 2025, https://docs.databricks.com/gcp/en/sql/language-manual/sql-ref-syntax-qry-select-sampling
TABLESAMPLE clause - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/sql/language-manual/sql-ref-syntax-qry-select-sampling
View data lineage using Unity Catalog - Azure Databricks - Microsoft Learn, accessed November 25, 2025, https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/data-lineage
