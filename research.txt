
Arquitetura de Orquestração Multi-Agente e Gerenciamento de Estado Não-Linear em Interfaces React para GenAI


1. Sumário Executivo e Tese Arquitetural

A evolução das interfaces de conversação baseadas em Grandes Modelos de Linguagem (LLMs) está transitando de um paradigma de chat linear e reativo para arquiteturas cognitivas complexas, caracterizadas pela orquestração multi-agente, persistência de estado ramificada e integração profunda com ferramentas de execução de código. O presente relatório técnico delineia uma estratégia exaustiva para transformar a aplicação existente — identificada nos artefatos do projeto como diegomrodrigues2-databricks-dashboard-app — de um visualizador de dashboards passivo com overlay de chat em um Ambiente de Desenvolvimento Integrado Generativo (GenIDE) completo.1
A análise da base de código atual revela uma fundação sólida construída sobre React 19, TypeScript e Vite, utilizando Tailwind CSS para estilização e IndexedDB para persistência local via sessionService.ts.1 A aplicação já implementa conceitos avançados de "Generative UI" (GenUI) através do DynamicWidgetRenderer.tsx e de um parser de streaming robusto em streamParser.ts capaz de diferenciar raciocínio (<thought>), comandos de ferramentas (<command>) e configurações de widgets (<widget>).1 Contudo, o modelo de estado atual, encapsulado no hook useChat.tsx, opera sob uma premissa linear estrita, onde cada mensagem possui um único sucessor e o "Assistente" é uma entidade monolítica definida por um prompt de sistema estático gerado em promptFactory.ts.1
Para atender aos quatro requisitos estratégicos solicitados — (1) Seleção pré-sessão de modos e ferramentas, (2) Criação e customização de agentes, (3) Alternância dinâmica de agentes (Hot-Swapping) e (4) Ramificação conversacional (Branching) — é imperativo realizar uma refatoração estrutural profunda. A tese central deste relatório é que a aplicação deve abandonar a estrutura de dados de array linear para o histórico de mensagens em favor de um Grafo Acíclico Dirigido (DAG) normalizado. Adicionalmente, o conceito de "Sistema" deve ser abstraído para permitir a injeção dinâmica de AgentDefinitions em tempo de execução, transformando o frontend em um orquestrador agnóstico que gerencia o contexto e a renderização para múltiplos atores cognitivos.
Este documento detalha a implementação dessas mudanças, abordando desde a redefinição das interfaces TypeScript em types.ts até a lógica de renderização virtualizada necessária para suportar árvores de conversação complexas, garantindo que a integridade dos dados e a performance da aplicação sejam mantidas ou aprimoradas.

2. Desconstrução da Arquitetura Base e Diagnóstico Técnico

Antes de propor a arquitetura de destino, é crucial realizar uma autópsia técnica da implementação vigente para identificar os pontos de acoplamento e as limitações que impedem a implementação imediata dos novos recursos. A base de código fornecida demonstra um nível de maturidade elevado, mas otimizado para um fluxo de trabalho específico que estamos prestes a romper.

2.1 O Monólito de Estado: Análise do useChat.tsx

O núcleo lógico da aplicação reside no hook customizado hooks/useChat.tsx. Atualmente, o estado da aplicação é definido pela interface ChatState, que mantém um array linear de mensagens:

TypeScript


interface ChatState {
  messages: Message;
  isChatOpen: boolean;
  status: 'idle' | 'thinking' | 'executing_tool' | 'streaming_response' | 'awaiting_input';
  activeToolCallId: string | null;
  currentSessionId: string | null;
}


A análise deste estado revela bloqueios fundamentais para os requisitos solicitados:
Linearidade Forçada: A propriedade messages: Message implica que a mensagem no índice $n$ é sempre a resposta à mensagem no índice $n-1$ (ou uma continuação do sistema). Isso torna impossível o Branching (Requisito 4), onde uma mensagem no índice $n$ poderia ter múltiplos sucessores alternativos baseados em diferentes escolhas do usuário ou regenerações de resposta.1
Estado Global de Execução: O campo status é global para a sessão. Em um cenário multi-agente (Requisito 3), onde o Agente A pode estar "pensando" enquanto o Agente B aguarda, ou onde o usuário deseja interagir com um ramo anterior da conversa enquanto o atual processa uma query longa no Databricks, um único status global é insuficiente.
Acoplamento de Sessão: A dependência direta de currentSessionId com um array simples dificulta a navegação entre "versões" da mesma conversa sem recarregar todo o contexto do sessionService.ts.1

2.2 A Fábrica de Prompts Estática: promptFactory.ts

A geração das instruções para o LLM é controlada por services/chat/promptFactory.ts. A função generateSystemPrompt consome a configuração global da aplicação (AppConfig) e constrói um prompt de sistema único e massivo.1

TypeScript


export function generateSystemPrompt(appConfig: AppConfig): string {
  //... extração de metadados de ferramentas...
  return `You are an intelligent data assistant...
  You have access to the following tools: ${toolsInfo}
 ...`;
}


Este design viola o Requisito 2 (Criação de Agentes Diferentes). O código atual assume uma identidade singular ("intelligent data assistant"). Para suportar múltiplos agentes, esta lógica precisa ser invertida: o sistema não deve ditar o prompt com base na configuração do app, mas sim aceitar uma AgentDefinition que traga suas próprias diretrizes, tom de voz e restrições de ferramentas. A promptFactory deve se tornar uma função pura que compila o prompt final combinando o contexto do agente com o contexto da sessão, e não uma constante global.

2.3 O Parser Léxico de Streaming: streamParser.ts

Um dos ativos mais valiosos da base de código atual é o utils/streamParser.ts. Diferente de implementações ingênuas que esperam a resposta completa, este parser atua como um tokenizador léxico em tempo real, capaz de identificar e segregar blocos de conteúdo misto.1
A função parseStreamedContent escaneia o buffer de entrada em busca de tokens delimitadores específicos:
<thought>...</thought>: Para Cadeia de Pensamento (CoT).
<command tool="...">...</command>: Para chamadas de função RPC.
WIDGET_START_TOKEN / WIDGET_END_TOKEN: Para injeção de JSON de configuração de UI.
Blocos Markdown padrão.
A robustez deste parser, evidenciada pelo seu loop de processamento (while (cursor < length)), é fundamental para a estabilidade do sistema. No entanto, para suportar a troca de agentes, o parser pode precisar evoluir para suportar "namespaces" ou formatos de saída variáveis, caso diferentes agentes (ex: um modelo Python especializado vs. um modelo SQL) utilizem convenções de saída ligeiramente diferentes. Além disso, o parser atual não parece manter estado entre chunks de mensagens quebradas, o que pode ser um ponto de falha se a ramificação da conversa ocorrer exatamente no meio de um token de controle.

2.4 Renderização Dinâmica e Ecossistema de Widgets

O arquivo components/chat/DynamicWidgetRenderer.tsx atua como o dispatcher central para a Generative UI. Ele mapeia a configuração JSON recebida para componentes React concretos, como BarChartComponent, CodeExecutionWidget, ou TableChartComponent.1
Uma análise detalhada do components/charts/ revela uma biblioteca rica baseada em D3.js (d3-scale, d3-shape, d3-array) e componentes SVG puros, em vez de depender de bibliotecas de gráficos de alto nível pesadas como Recharts ou Chart.js.1
Implicação de Performance: O uso de D3 de baixo nível é excelente para performance, permitindo granulação fina na renderização.
Implicação para Ramificação: O DynamicWidgetRenderer atual dispara um efeito colateral (useEffect) para buscar dados (getDataForSource) assim que é montado.1 Em uma arquitetura de ramificação, onde o usuário pode alternar rapidamente entre diferentes "versões" de uma resposta, isso causará requisições de rede redundantes e "flickering" visual. A arquitetura futura precisará implementar um cache de dados no nível da sessão ou do componente para evitar re-buscas desnecessárias ao navegar pelo histórico da árvore de conversa.

2.5 Execução de Código e Segurança

O componente CodeExecutionWidget.tsx permite a edição e execução de SQL e Python. Atualmente, ele invoca executeRawQuery em dashboardService.ts.1
Risco Crítico de Segurança: O arquivo vite.config.ts expõe process.env.DATABRICKS_TOKEN via a propriedade define.1 Isso injeta o token de autenticação diretamente no bundle JavaScript do cliente. Em uma arquitetura onde agentes podem ser criados e customizados pelo usuário, isso amplia a superfície de ataque. A nova arquitetura deve obrigatoriamente mover a execução de código para um proxy Backend-for-Frontend (BFF) para ocultar credenciais e sanitizar inputs, especialmente quando permitimos que agentes gerem SQL arbitrário.

3. Pilar 1: Configuração Pré-Voo (Seleção de Modo e Ferramentas)

O primeiro requisito exige que o usuário selecione o modo de operação e as ferramentas disponíveis antes de iniciar a interação. Isso transforma o chat de um utilitário "sempre ligado" para uma "Sessão Configurada".

3.1 Contexto de Configuração da Sessão

Atualmente, o useChat inicializa uma sessão imediatamente. Precisamos introduzir um estado de "Lobby". Isso deve ser modelado formalmente em types.ts. Devemos estender a definição de Session para incluir metadados de configuração que persistirão por toda a vida daquela conversa.

TypeScript


// types.ts - Extensão Proposta

export type ChatMode = 'fast-response' | 'deep-analysis' | 'code-generation' | 'creative';

export interface SessionConfig {
  mode: ChatMode;
  allowedTools: string; // Lista de IDs de ferramentas permitidas (ex:)
  modelTemperature: number;
  maxTokens?: number;
  systemPromptOverride?: string; // Para casos avançados
}

export interface Session {
  id: string;
  title: string;
  config: SessionConfig; // Novo campo obrigatório
  // A estrutura de messages mudará no Pilar 4, mas por enquanto mantemos a referência
  messages: Message; 
  createdAt: number;
  updatedAt: number;
}



3.2 UI do Intersticial de Configuração ("O Lobby")

Em vez de renderizar diretamente o ChatInput e MessageList em ChatWindow.tsx 1, devemos implementar uma verificação de estado. Se a sessão for nova e não tiver configuração, renderizamos o componente SessionSetup.
Este componente deve interagir com o services/toolRegistry.ts, que já exporta getAllToolDefinitions e a lista de ferramentas disponíveis (searchData, listTables).1
Design Funcional do SessionSetup.tsx:
Seletores de Modo (Cards):
Analista de Dados: Pré-configura ferramentas de leitura (searchData, listTables) e widgets de visualização. Temperatura 0.2 (preciso).
Engenheiro de Dados: Habilita code-executor para SQL/Python e acesso a ferramentas de schema. Temperatura 0.1 (determinístico).
Explorador Criativo: Desabilita ferramentas estritas, aumenta a temperatura para 0.8. Foco em brainstorming.
Toggle de Ferramentas (Granularidade Fina):
Abaixo da seleção de modo, uma lista de checkboxes gerada a partir de toolRegistry.ts permite ao usuário refinar o acesso. Por exemplo, um usuário pode querer o modo "Analista" mas desabilitar o acesso a dados sensíveis (user_table), caso a ferramenta suporte tal granularidade.
Disparo de Ação:
O botão "Iniciar Sessão" despacha uma ação SET_SESSION_CONFIG para o redutor do chat, salva a estrutura inicial no IndexedDB via sessionService.ts e transiciona a view para a interface de chat principal.

3.3 Filtragem de Ferramentas no Backend

A função generateSystemPrompt em services/chat/promptFactory.ts deve ser refatorada para aceitar SessionConfig. O prompt do sistema não deve mais listar todas as ferramentas indiscriminadamente.

TypeScript


// services/chat/promptFactory.ts (Refatoração)

import { getAllToolDefinitions } from '../toolRegistry';

export function generateSystemPrompt(appConfig: AppConfig, sessionConfig?: SessionConfig): string {
  const allTools = getAllToolDefinitions();
  
  // Filtragem baseada na configuração da sessão
  const enabledTools = sessionConfig 
   ? allTools.filter(t => sessionConfig.allowedTools.includes(t.name)) 
    : allTools;
    
  const toolsInfo = enabledTools.map(t => {
      return `- Tool: "${t.name}"\n Description: ${t.description}\n Parameters: ${JSON.stringify(t.parameters)}`;
  }).join('\n');
  
  // Instruções específicas de modo
  let modeInstructions = "";
  if (sessionConfig?.mode === 'code-generation') {
      modeInstructions = "Prioritize using the code-executor widget. Output raw SQL/Python frequently and avoid summarizing data unless requested.";
  } else if (sessionConfig?.mode === 'deep-analysis') {
      modeInstructions = "Always analyze the data for trends, outliers, and correlations. Use Charts aggressively.";
  }
  
  return `You are an intelligent data assistant...
  ${modeInstructions}
  You have access to the following tools:
  ${toolsInfo}
 ...`;
}


Isso garante que o modelo de linguagem (LLM) alucine menos sobre ferramentas que não pode usar e adira estritamente ao comportamento esperado pelo modo selecionado.

4. Pilar 2: Arquitetura de Agentes Customizáveis

O segundo requisito é permitir a criação de diferentes agentes na interface através da customização do prompt de sistema. Isso exige a abstração do conceito de "Assistente" para uma entidade configurável: a AgentDefinition.

4.1 O Padrão de Registro de Agentes (AgentRegistry)

Devemos criar um novo serviço services/agentRegistry.ts, análogo ao toolRegistry.ts 1, mas focado em personas. Além disso, precisamos de persistência para agentes criados pelo usuário. O dashboardStorageService.ts usa IndexedDB 1; devemos estendê-lo ou criar um agentStorageService.ts com um store agents no banco dashboards_db (ou um novo banco agents_db).
Definição da Entidade Agente:

TypeScript


export interface AgentDefinition {
  id: string;
  name: string;
  role: string; // ex: "Senior SQL Architect"
  description: string;
  avatarUrl?: string; // Para customizar o ícone em MessageBubble.tsx
  baseSystemPrompt: string;
  defaultTools: string; // IDs das ferramentas que este agente prefere
  capabilities: {
    canGenerateCharts: boolean;
    canExecuteCode: boolean;
    canBrowseInternet: boolean; // Preparação para futuro
  };
  style: {
    tone: 'formal' | 'casual' | 'didactic' | 'concise';
    verboseReasoning: boolean; // Se deve mostrar <thought> ou ocultar
  };
  isSystemDefault: boolean; // Para proteger agentes base contra deleção
}



4.2 Interface de Criação de Agentes

A aplicação possui uma página ConfigPage.tsx que atualmente é um placeholder.1 Esta página deve ser transformada no centro de gerenciamento de agentes.
Utilizando os componentes de formulário já existentes em components/forms/ (como TextInput, TextareaInput, SelectInput, CodeExecutionWidget para testar prompts) 1, devemos construir um editor visual:
Identidade: Campos para Nome, Função e Avatar.
Prompt Engineering: Um TextareaInput grande para o baseSystemPrompt. Aqui o usuário define "Você é um especialista em SQL que odeia usar JOINs desnecessários...".
Capabilities: CheckboxGroup para selecionar ferramentas permitidas.
Teste de Playground: Um mini-chat embutido na página de configuração para testar o agente antes de salvar.

4.3 Injeção de Prompt em Tempo de Execução

No momento do início do chat (ou troca de agente), o useChat deve recuperar a definição completa do agente.
A função streamChatResponse em services/chatService.ts precisa ser atualizada. Atualmente, ela chama generateSystemPrompt sem argumentos de agente.1 A nova assinatura deve ser:

TypeScript


export async function streamChatResponse(
  messages: Message, 
  agent: AgentDefinition, // Injeção de Dependência do Agente
  sessionConfig: SessionConfig,
  onChunk: (chunk: string) => void
): Promise<void> {
    
  // Compilação do Prompt Híbrido
  const finalSystemPrompt = `
    ${agent.baseSystemPrompt}
    
    [Operational Constraints]
    Tone: ${agent.style.tone}
    Allowed Tools: ${getToolsFromIds(sessionConfig.allowedTools.filter(t => agent.defaultTools.includes(t)))}
    
    ${WIDGET_SCHEMA_DEFINITION} 
  `;
  
  const apiMessages =;
  
  //... fetch para Databricks...
}


Esta composição garante que as regras do Agente (personalidade) e as regras da Sessão (segurança/ferramentas) sejam fundidas antes de chegar ao LLM.

5. Pilar 3: Alternância Dinâmica de Agentes (Hot-Swapping)

O Requisito 3 permite selecionar e alterar o agente durante uma conversa ativa. Isso introduz o desafio de manter a coerência do contexto quando a "persona" do interlocutor muda abruptamente.

5.1 Gerenciamento de Contexto e Handoff

Quando o usuário troca de Agente A para Agente B na interface (via um novo Dropdown no ChatHeader.tsx ou acima do ChatInput.tsx), o estado currentAgentId no useChat é atualizado. No entanto, o LLM não "sabe" que mudou de identidade a menos que o instruamos explicitamente no fluxo de mensagens.
Simplesmente mudar o prompt do sistema na próxima requisição pode confundir o modelo, pois o histórico anterior reflete o comportamento do Agente A. Devemos implementar um padrão de "Mensagem de Sistema de Transição".
Quando ocorre a troca, injetamos uma mensagem invisível (ou visível como "Evento de Sistema") no histórico que será enviado na próxima interação:

JSON


{
  "role": "system",
  "content": ": The active assistant has been switched to 'Business Analyst Agent'. You must now adopt the persona defined in your system prompt. Review the conversation history context provided by the previous agent, but answer future queries focusing on business KPIs and ROI analysis rather than technical SQL details."
}


Isso força o modelo a recalibrar sua atenção para as novas diretrizes.

5.2 Atualizações de UI para Conversas Multi-Persona

O componente MessageBubble.tsx atualmente renderiza um ícone genérico de "AI" para mensagens do assistente.1 Para suportar uma conversa fluida com múltiplos agentes, cada mensagem deve carregar metadados sobre quem a gerou.
Precisamos atualizar a interface Message em types.ts:

TypeScript


export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  // Novos campos de metadados de autoria
  authorId?: string; // ID do Agente ou Usuário
  authorName?: string; // Snapshot do nome no momento da geração
  authorAvatar?: string; // URL do avatar
  //... outros campos existentes
}


No MessageBubble.tsx, a renderização condicional do avatar deve usar esses campos:

TypeScript


// components/chat/MessageBubble.tsx

const MessageBubble: React.FC<MessageBubbleProps> = ({ message }) => {
  //...
  return (
    <div className="flex items-start gap-3...">
      <div className="flex-shrink-0 w-8 h-8...">
        {message.authorAvatar? (
          <img src={message.authorAvatar} alt={message.authorName} className="rounded-full" />
        ) : (
          <DefaultAIIcon />
        )}
      </div>
      <div className="flex flex-col...">
         {/* Label do Autor para clareza em chats multi-agente */}
         <span className="text-xs text-gray-400 ml-1 mb-1">{message.authorName |

| 'Assistant'}</span>
         <div className="...">
            {/* Conteúdo */}
         </div>
      </div>
    </div>
  );
};


Isso fornece clareza visual imediata sobre quem disse o quê, essencial quando múltiplos agentes colaboram em um único problema.

6. Pilar 4: Ramificação Conversacional (O Modelo de Multiverso)

O requisito mais complexo é a criação de branchs (ramificações): "recomeçar a conversa de um ponto e ainda assim voltar para uma branch anterior". Isso exige abandonar o modelo linear de array (Message) em favor de uma estrutura de dados de Árvore ou Grafo.

6.1 Da Lista Linear para o Grafo Direcionado

Atualmente, messages é uma lista onde $i$ precede $i+1$. Devemos adotar uma estrutura onde cada mensagem aponta para seu pai, e pode ter múltiplos filhos.
Novo Esquema de Dados (types.ts):

TypeScript


export interface TreeMessage extends Message {
  id: string;
  parentId: string | null; // null se for a raiz da conversa
  childrenIds: string; // Lista de IDs de mensagens que responderam a esta
}

export interface Session {
  id: string;
  // messageMap armazena todas as mensagens de todos os branches, indexadas por ID
  messageMap: Record<string, TreeMessage>; 
  // currentLeafId aponta para a mensagem final do branch que o usuário está visualizando agora
  currentLeafId: string | null; 
  //... outros campos
}



6.2 Algoritmo de Travessia e Renderização

O componente MessageList.tsx 1 não pode mais simplesmente mapear um array. Ele precisa de um "Seletor de Thread".
Criamos uma função utilitária getThreadFromLeaf(leafId: string, messageMap: Record<string, TreeMessage>): TreeMessage.
Lógica do Algoritmo:
Comece no leafId.
Adicione a mensagem atual a um array temporário.
Busque o parentId da mensagem atual.
Se parentId existir, mova o cursor para o pai e repita o passo 2.
Se parentId for nulo, pare.
Inverta o array temporário (para ter ordem cronológica: Raiz -> Folha).
O useChat exporá este array linear derivado (messages) para que o MessageList possa renderizar sem saber que existe uma árvore complexa por trás.

6.3 Interface de Navegação entre Branches

O MessageBubble.tsx precisa ganhar controles de navegação. Se uma mensagem tiver childrenIds.length > 1, significa que há múltiplos caminhos a partir daquele ponto.
Implementação Visual:
No rodapé do balão de mensagem, adicionamos setas de navegação < e > e um contador 2 / 5.
Ação de Clique < (Anterior): Busca o índice do filho atual no array childrenIds e seleciona o índice anterior. Atualiza o currentLeafId da sessão descendo por aquele novo caminho até o final.
Ação de Clique Edit (Criar Branch): Ao editar uma mensagem de usuário antiga, não mutamos o conteúdo. Criamos uma nova mensagem com o mesmo parentId da mensagem editada. O sistema automaticamente a adiciona ao childrenIds do pai e atualiza o currentLeafId para esta nova mensagem, efetivamente criando um novo universo paralelo de conversa.

6.4 Redutor de Estado Baseado em Grafo

O chatReducer em useChat.tsx 1 precisa ser reescrito para operações de grafo.
Lógica Atual (Linear):

TypeScript


case 'SEND_MESSAGE':
  return {...state, messages: [...state.messages, action.payload] };


Nova Lógica (Branching):

TypeScript


case 'SEND_MESSAGE':
  const parentId = state.currentLeafId; // O novo pai é a folha atual
  const newMessage: TreeMessage = { 
     ...action.payload, 
      parentId, 
      childrenIds: 
  };
  
  // Atualizar o pai para incluir este novo filho
  const parentMessage = state.messageMap[parentId];
  const updatedParent = { 
   ...parentMessage, 
    childrenIds: [...parentMessage.childrenIds, newMessage.id] 
  };

  return {
   ...state,
    messageMap: {
     ...state.messageMap,
      [parentId]: updatedParent,
      [newMessage.id]: newMessage
    },
    currentLeafId: newMessage.id // Avança a ponta do branch atual
  };


Isso garante que nenhum histórico seja perdido. O usuário pode sempre "voltar" para o branch original navegando pelos childrenIds do nó pai.

7. Otimização de Renderização e Performance em React

A introdução de uma estrutura de árvore e a renderização de múltiplos widgets pesados (D3.js) exigem cuidado extremo com a performance para evitar travamentos da UI.

7.1 Virtualização da Lista de Mensagens

À medida que os branches crescem, renderizar centenas de componentes MessageBubble (cada um contendo potenciais DynamicWidgetRenderer) se torna custoso. O arquivo MessageList.tsx atualmente renderiza um map simples e usa scrollIntoView.1
Devemos migrar para react-window (já presente no package.json 1 para a planilha) ou react-virtuoso. A virtualização garantirá que apenas as mensagens visíveis no viewport sejam montadas no DOM, reduzindo drasticamente a pegada de memória e o tempo de renderização do React Reconciliation.

7.2 Estratégia de Memoização de Widgets

O DynamicWidgetRenderer possui um defeito crítico para a arquitetura de branching proposta. Ele carrega dados no efeito colateral de montagem:

TypeScript


// components/chat/DynamicWidgetRenderer.tsx 
useEffect(() => {
  const fetchData = async () => {... getDataForSource... }
  fetchData();
},);


Se um usuário navegar entre branches (ex: trocar da versão 1 da resposta para a versão 2), os componentes serão desmontados e remontados. Isso disparará novas requisições de rede (getDataForSource), causando lentidão e "loading spinners" desnecessários.
Solução: Cache de Contexto de Dados (DataCacheContext)
Devemos implementar um cache global para a sessão. Antes de o widget disparar o fetch, ele verifica o cache.

TypeScript


// hooks/useDataCache.tsx (Novo Hook)
const useDataCache = (queryKey: string, fetcher: () => Promise<any>) => {
  const { cache, setCache } = useContext(DataCacheContext);
  
  useEffect(() => {
    if (!cache[queryKey]) {
      fetcher().then(data => setCache(queryKey, data));
    }
  }, [queryKey]);

  return cache[queryKey];
};


O DynamicWidgetRenderer deve ser atualizado para usar este hook, usando uma chave composta (ex: dataSource + filtros) para garantir que a alternância entre branches seja instantânea (Optimistic UI).

8. Segurança e Governança

A transição para um sistema onde usuários definem agentes e executam código exige controles de segurança rigorosos.

8.1 Vazamento de Segredos no Cliente (Token Databricks)

O arquivo vite.config.ts atual expõe DATABRICKS_TOKEN via define.1 Isso incorpora o token hardcoded no bundle JS final entregue ao navegador. Qualquer usuário com conhecimento básico de DevTools pode extrair esse token e executar queries arbitrárias contra o cluster Databricks.
Mitigação Obrigatória: Implementação de um Backend-for-Frontend (BFF). O cliente React deve enviar a intenção de execução (query, tool_name) para um endpoint /api/execute-tool. O servidor (Node.js/Express ou Next.js API Route) mantém o segredo DATABRICKS_TOKEN, valida a sessão do usuário, aplica Rate Limiting e só então encaminha a requisição para o Databricks.

8.2 Prevenção de Injeção de Prompt e SQL

Permitir que usuários criem agentes com prompts customizados cria o risco de "Prompt Injection", onde um agente malicioso é desenhado para exfiltrar dados ou ignorar diretrizes de segurança.
Além disso, o CodeExecutionWidget permite rodar SQL. Se o agente gera DROP TABLE fruit_sales, e o widget está configurado como autoExecute: true (embora o padrão seja false 1), dados podem ser perdidos.
Defesa em Profundidade:
Validação de Esquema: O toolRegistry.ts deve validar rigidamente os parâmetros.
Code Review Forçado: Para ações destrutivas (detectadas via regex simples como DROP, DELETE, ALTER no SQL), o widget CodeExecutionWidget deve forçar a prop isEditable: true e autoExecute: false, e exibir um aviso visual de alto risco (componente ExclamationTriangleIcon já existente 1).
RBAC (Role-Based Access Control): Utilizar o objeto User do useAuth.tsx 1 para restringir o acesso ao "Modo Engenheiro" apenas para usuários com role admin.

9. Tabelas Comparativas e de Especificação

Abaixo apresentamos especificações detalhadas para auxiliar a implementação.

Tabela 9.1: Comparação de Modelos de Estado de Mensagem

Característica
Modelo Atual (Linear)
Modelo Proposto (Grafo/Árvore)
Benefício Arquitetural
Estrutura
Array<Message>
Map<ID, Message> + LinkedList
Acesso O(1) a qualquer nó; suporte a múltiplos pais/filhos.
Navegação
Scroll Vertical Apenas
Scroll Vertical + Navegação Horizontal entre Branches
Permite explorar cenários alternativos ("E se eu tivesse perguntado diferente?").
Persistência
Simples (JSON Blob)
Complexa (Requer normalização)
Maior integridade referencial; permite carregar branches parciais (lazy loading).
Contexto
Janela deslizante simples
Reconstrução de caminho raiz-folha
Otimiza o uso de tokens enviando apenas o "caminho ativo" para o LLM.


Tabela 9.2: Especificação de Propriedades do CodeExecutorWidget (Atualizado)

O widget de execução de código é central para a capacidade agêntica.
Propriedade
Tipo
Padrão
Descrição & Requisito de Segurança
type
'code-executor'
-
Discriminador para o DynamicWidgetRenderer.
language
'sql' | 'python' | 'scala'
'sql'
Define o highlighting (PrismJS) e o backend de execução.
code
string
-
O payload gerado pelo agente. Deve ser sanitizado antes de renderizar.
isEditable
boolean
true
Permite ao humano corrigir o código do agente. Crítico para Human-in-the-Loop.
autoExecute
boolean
false
Se true, executa ao montar. DEVE ser false para operações de escrita/delete.
riskLevel
'low' | 'high'
'low'
(Novo) Inferido pelo parser. Se 'high', bloqueia auto-execução e exige confirmação dupla.
context
object
{}
Metadados de catálogo/schema necessários para execução no Databricks.


10. Conclusão

A implementação do plano detalhado neste relatório elevará o diegomrodrigues2-databricks-dashboard-app de uma ferramenta de visualização competente para uma plataforma de orquestração cognitiva de classe empresarial. A mudança para uma estrutura de dados de grafo para o histórico de chat é a pedra angular que habilita funcionalidades avançadas como o branching, enquanto a abstração do registro de agentes e ferramentas permite uma flexibilidade operacional sem precedentes.
Aproveitando a base sólida de componentes React e utilitários de parsing já existentes, o esforço de engenharia pode se concentrar na lógica de estado e segurança, minimizando o retrabalho de UI. Este roteiro não apenas atende aos requisitos imediatos do usuário, mas prepara a aplicação para um futuro onde múltiplos agentes especializados colaborarão de forma autônoma para resolver problemas de dados complexos, sempre sob a supervisão e controle do operador humano.
Works cited
diegomrodrigues2-databricks-dashboard-app-8a5edab282632443 (3).txt
